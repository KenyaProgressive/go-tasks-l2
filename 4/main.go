package main

func main() {
	ch := make(chan int) // создание небуферизированного канала
	go func() {
		for i := 0; i < 10; i++ {
			ch <- i // Кладем число в канал, горутина блокируется
		}
		/// исправление ошибки ---> close(ch)
	}()
	for n := range ch {
		println(n) // Печать значение из канала, горутина записи разблокировалась
	}
}

// канал не был закрыт, поэтому возникнет deadlock в main-горутине, которая блокируется при отсутсвии значения в канале, а горутина записи уже завершена
